#!/usr/bin/env perl

use strict;
use warnings;

use 5.012;

use utf8::all; # lots of funky chars in here

use Getopt::Std;

our %opt;
getopts( 'cFnvC:Di:', \%opt);

if( $opt{p}) { $opt{s}=1; }

import pelt;

use Parse::RecDescent;
#$::RD_HINT=1;
$::RD_ERRORS = 1;
#$::RD_TRACE = 1;


# empirically found list of formats found in mif prompt[] with the corresponding character
# s10.00s generating 'â‹®' makes absolutley no sense, s normaly specifies the size of the character
# see https://help.adobe.com/en_US/framemaker/mifreference/mifref.pdf p 203
# I am probably missing something there...
my %prompt= ( '(*s10.00s*)' => 'â‹®');

my $grammar=<<'G'; 
{
my %ent=
    ( # p 182-184 of the MIF reference Manual
      aleph     => '×', alpha     => 'Î±', beta      => 'Î²', bot       => 'âŠ¥', chi       => 'Ï‡', cpartial  => 'âˆ‚',
      degree    => 'Â°', delta     => 'Î´', Delta     => 'âˆ†', emptyset  => 'âˆ…', epsilon   => 'Îµ', eta       => 'Î·',
      gamma     => 'Î³', Gamma     => 'Î“', Im        => 'ð”', infty     => 'âˆž', iota      => 'Î¹', kappa     => 'Îº',
      lambda    => 'Î»', Lambda    => 'Î›', ldots     => 'â€¦', mu        => 'Î¼', nabla     => 'âˆ‡', nu        => 'Î½',
      omega     => 'Ï‰', Omega     => 'Î©', phi       => 'Ï†', Phi       => 'Î¦', pi        => 'Ï€', Pi        => 'Î ',
      pprime    => 'â€³', prime     => 'â€²', psi       => 'Ïˆ', Psi       => 'Î¨', Re        => 'â„œ', rho       => 'Ï',
      sigma     => 'Ïƒ', Sigma     => 'Î£', tau       => 'Ï„', theta     => 'Î¸', Theta     => 'Î˜', upsilon   => 'Ï…',
      Upsilon   => 'Î¥', varphi    => 'Ï†', varpi     => 'Ï€', varsigma  => 'Ï‚', vartheta  => 'Î¸', wp        => 'â„˜',
      xi        => 'Î¾', Xi        => 'Îž', zeta      => 'Î¶',
      # p 186-189 of the MIF reference Manual
      leq       => 'â‰¤', geq       => 'â‰¥', lessthan  => '<', notequal  => 'â‰ ', greaterthan => '>',
      infty     => 'âˆž', rarr      => 'â†’', caret     =>'â€¸', tprime    => 'â€´', rabracket => 'â€º', labracket => 'â€¹',
      tie       => 'â€', overline  => 'â€¾', dagger    => 'â€ ', geq       => 'â‰¥', leq       => 'â‰¤', sum       => 'âˆ‘',
      int       => 'âˆ«', dot       => 'â‹…', twodots   => 'â€¥', ellip     => 'â€¦', box       => 'â–¡', angle     => 'âˆ ',
      bullet    => 'â€¢', times     => 'â¨‰', exists    => 'âˆƒ', forall    => 'âˆ€', minusplus => 'âˆ“', plusminus => 'Â±',
      neg       => 'Â¬', therefore => 'âˆ´',
      topcurly  => 'ï¸·', bottomcurly => 'ï¸¸', 
    );

my %is_ent= map { $_ => 1 } values %ent; # sometimes we need to know if a character is an entity     

# to replace characters in the symbol font by the real character - from http://www.alanwood.net/demos/symbol.html
# I have only included greek characters, as they are the only ones I have seen used (local copy in symbol.html)
my %symbol=
    ( a => 'Î±', b => 'Î²', c => 'Ï‡', d => 'Î´', e => 'Îµ', f => 'Ï†', g => 'Î³', h => 'Î·', i => 'Î¹', j => 'Ï•', k => 'Îº', l => 'Î›',  m => 'Î¼',
      n => 'Î½', o => 'Î¿', p => 'Ï€', q => 'Î¸', r => 'Ï', s => 'Ïƒ', t => 'Ï„', u => 'Ï…', v => 'Ï–', w => 'Ï‰', x => 'Î¾', y => 'Ïˆ', z => 'Î¶',
      D => 'Î”', F => 'Î¦', G => 'Î“', J => 'Ï‘', L => 'Î›', P => 'Î ', Q => 'Î˜', S => 'Î£',  U => 'Î¥', V => 'Ï‚', Y => 'Î¨', W => 'Î©', 
      O => 'Î©', 
    );
# to replace escaped characters in strings or chars
my %frame_escape=
    ( t      => "\t", '>' => '>', q => "'", Q => '`', '\\' => '\\', # p 7 of the MIF reference Manual
      'xd0 ' => 'â€“',                                                # found this in an equation, don't know why d0 is a dash
    );

# replace a letter with a bar above, but the bar is lowered to create a letter with stroke
my %with_stroke=
    ( b => 'Æ€', d => 'Ä‘', f => 'êž™', g => 'Ç¥', h => 'Ä§', i => 'É¨', j => 'É‰',
      k => 'ê', p => 'áµ½', r => 'É', t => 'Å§', y => 'É', z => 'Æ¶',
      B => 'Éƒ', D => 'Ä', F => 'êž˜', G => 'Ç¤', H => 'Ä¦', I => 'Æ—', J => 'Éˆ', 
      K => 'ê€', P => 'â±£', R => 'ÉŒ', T => 'Å¦', Y => 'ÉŽ', Z => 'Æµ',
    );

# nodes (operators in the MIF Reference)

# these types of node require specific processing
my %special=
  ( times => sub { mrow( @_); },
    id          => \&id,
    chem        => \&chem,  
    tensor      => \&tensor,  
    matrix      => \&matrix,  
    lparen      => \&lparen,
    rparen      => \&rparen,
    indexes     => \&indexes,
    diacritical => \&diacritical,
    atop        => \&atop,
    ast         => sub { mrow( msup( $_[0], mo('âˆ—'))); },
    box2        => sub { mrow( msup( mi($ent{box}), mi(2)), @_); },
    downbrace   => sub { mover( mrow( $_[0]), mo( $ent{topcurly})); },
    lap         => sub { mrow( msup( mi($ent{nabla}), mi(2)), @_); },
    overline    => sub { mover( shift(), mo( $ent{overline})); },
    upbrace     => sub { munder( mrow( $_[0]), mo( $ent{bottomcurly})); },
    acmut       => sub { mfenced( { sep => [ '{', '}', ','] }, @_); },
    bket        => sub { mfenced( { sep => [ 'ã€ˆ', 'ã€‰', '|'] }, @_); },
    cmut        => sub { mfenced( { sep => [ '[', ']', ','] }, @_); },
    inprod      => sub { mfenced( @_); },
    choice      => sub { mfenced( mfrac( { linethickness => 0 }, @_)); },
    function    => sub { my $func= shift; 
                         if( $func->from_in( qw(oppartial optotal)))
                           { mrow( $func, mrow( @_)); }
                         else
                           { mrow( $func, mfenced( @_)); }
                       },
    lim         => sub { munder( mrow( mo( 'lim'), shift()), mrow( shift)); },
    over        => sub { mfrac( mrows( @_));  },
    power       => sub { msup( mrows( @_));   },
    sn          => sub { my $format= shift;
                         if( $format->{i} == 1) { op( 'E', @_); }
                         else                   { mrow( shift(), mo( 'Ã—') , msup( mi(10), shift())); } 
                       },
    plus        => sub { # if next mo is a -, plusminus or minusplus, the + is not used
                         my @children= shift( @_);
                         foreach my $child ( flatten(@_))
                           { if( ! $child->from_in( qw(minus mp pm)) )
                               { push @children, mo( '+'); }
                              push @children, $child;
                           }
                         return mrow( @children);
                       },
    minus       => sub { u_or_n_nary( '-'      => @_); },
    diff        => sub { mrow( moi( 'd'), @_); },
    dagger      => sub { return msup( @_, mo( $ent{dagger})); },
    grad        => sub { if( @_ == 1) { pre_op( 'âˆ‡', @_); }
                         else         { mrow( msub( mo('âˆ‡'), $_[1]), $_[0]); }
                       },

    log         => sub { if( @_ == 1) { pre_op( log => @_); }
                         else         { mrow( msub( mo('log'), $_[1]), $_[0]); }
                       },
    oppartial   => sub { if( @_ == 1) { mfrac( mrow( mo( 'âˆ‚')), mrow( mo('âˆ‚'), $_[0])); }
                         else         { mfrac( mrow( msup( mo( 'âˆ‚'), $_[1])), mrow( mo('âˆ‚'), mi( $_[0]))); }
                       },
    optotal     => sub { if( @_ == 1) { mfrac( mrow( mo( 'd')), mrow( mo('d'), $_[0])); }
                         else         { mfrac( mrow( msup( mo( 'd'), $_[1])), mrow( mo('d'), mi( $_[0]))); }
                   },
    sqrt        => sub { if( @_ == 1) { msqrt( @_); }
                         else         { mroot( @_); }
                       },
    substitution => sub { if(    @_ == 1) { post_op( shift(), '|'); }
                          elsif( @_ == 2) { msub( mrow( shift(), mo( '|')), shift()); }
                          else            { msubsup( mrow( shift(), mo( '|')), @_); }
                        },
    list  => sub { return mrow( @_); },
  );

# p 186-194 of the MIF reference Manual

# these nodes are displayed as the name of the node followed by the content
my @lit= qw( acos acosh acot acoth acsc acsch arg asec asech asin asinh atan atanh
             cos cosh cot coth csc csch exp imag ln real sec sech sgn sin sinh
             tan tanh
            );

# these nodes are displayed as a prefix ( different from the name of the node) followed by the content
# the data is <name> => <prefix>
my %pre_op= ( angle => 'âˆ ', box => 'â–¡', boxdot => 'â–¡â‹…',
              change => 'âˆ†', curl => 'âˆ‡â¨‰', 
              diver => 'âˆ‡â‹…', exists => 'âˆƒ', forall => 'âˆ€',
              mp => 'âˆ“', neg => 'Â¬', partial => 'âˆ‚', pm => 'Â±', 
              semicolon => ';', therefore => 'âˆ´', ucomma => ',', uequal => '=',
              var => 'Î´',
              
            ); 

# these nodes are displayed as the content wrapped between a prefix and a suffix
# the data is <name> => [ <prefix>, <suffix> ]
my %wrap = ( abs   => [ '|', '|' ], bra    => [ 'â€¹', '|' ],
             ceil  => [ 'âŒˆ', 'âŒ‰' ], dangle => [ '<', '>' ],
             floor => [ 'âŒŠ', 'âŒ‹' ], ket    => [ '|', 'â€º' ], 
             norm  => [ 'â€–', 'â€–' ],                             # (sometimes!) appears as 1 bar in my editor, should be 2
           );

# these nodes are displayed as the content, followed by a suffix
# the data is <name> => <suffix>
my %post_op= ( fact => '!', );

# these nodes are displayed as the list of contents, separated by an operator
# data is <name> => <operator>
my %nary=( approx => 'â‰ˆ', cap => 'âˆ©', cdot => 'â‹…', comma => ',', cong => 'â‰…', cup => 'âˆª', equal => '=',
           equiv => 'â‰¡', geq => 'â‰¥', gg => 'Â»',  greaterthan => '>', in => 'âˆˆ',  jotdot => 'â—Š', 
           leftarrow => 'â†', Leftarrow => 'â‡', leq => 'â‰¤', lessthan => '<', ll => 'Â«',
           lrarrow => 'â†”', LRarrow => 'â‡”', ni => 'âˆ‹', notequal => 'â‰ ', notin => 'âˆ‰', notsubset => 'âŠ„',
           oplus => 'âŠ•', otimes => 'âŠ—', parallel => '||', perp => 'âŠ¥', propto => 'âˆ', rightarrow => 'â†’',
           Rightarrow => 'â‡’', sim => 'âˆ¼', subset => 'âŠ‚', subseteq => 'âŠ†', supset => 'âŠƒ', supseteq => 'âŠ‡',
           vee => 'âˆ¨', wedge => 'âˆ§',
           # binaries that can be processed as n-ary
           bullet => 'â€¢', cross => 'Ã—', div => 'Ã·', fract => 'â„'
         );

# comparison operators (used to align atop with the proper format (j3j)), keys are the character, possibly created from the entity name
my %is_comp = map { $nary{$_} => 1 } qw( geq greaterthan leq lessthan notequal approx cong equal equiv in lrarrow Leftarrow lrarrow LRarrow notin rightarrow Rightarrow sim subset subseteq supset supseteq);


my %large=( bigcap => 'âˆ©', bigcup => 'âˆª', int => 'âˆ«', oint => 'âˆ«', prod => 'âˆ', sum => 'âˆ‘');

my $nbsp= "\N{U+A0}"; # replace spaces in strings and chars by nbsp, so they don't get thrown away by the display engines 

sub atop
  { my( $format, @mrows)= @_;
    my $align= exists $format->{j} &&  $format->{j} == 0 ? 'center'
             : $format->{j} == 1                         ? 'left'
             : $format->{j} == 2                         ? 'right'
             :                                             'left';
    my $mtable;
    if( $format->{j} >= 3 || atop_looks_like_should_be_aligned( @mrows))
      { $mtable= atop_aligned( $align, @mrows); } # j3j (or j4j) means "align on equal" 
    else
      { $mtable= mtable( { columnalign => $align }, map { mtr( mtd($_)) } @mrows); }

    return $mtable;
  }

# in some (lots of!) cases the lines are aligned vertically on the equal sign
# but this is done not by setting the proper format for atop (j3j) but by moving the following lines right
# so we get a first line that's equal, then the following are uequal (unitary equal), moved to the right, 
# which shows up in the mif as the x format (kern!) 
sub atop_looks_like_should_be_aligned
  { my( @mrows)= @_;
    return if ! @mrows;                     # no row
    my $first_row= shift @mrows;
    return if $first_row->from ne 'equal';  # if it's not equal, we're not in this case (TODO how about other comparison?)
    foreach my $cont_row (@mrows)           # all other lines should be uequal, with an x format
      { return if $cont_row->from ne 'uequal' || ! $cont_row->format( 'x'); }
    return 1;                               # if we get here then indeed it looks like the lines should be aligned on '='
  }


# receives a list of mrows, that should be aligned using an mtable (MathML choice, not mine!)

# example         [col1]                          [col2]      [col3]
#         <mrow>  <mi>a</mi>                      <mo>=</mo>  <mn>1</mn>  </mrow>   # regular line, with '='
#         <mrow>  <mi>a</mi><mo>+</mo><mi>b</mi>  <mo>=</mo>  <mn>0</mn>  </mrow>   # an other one
#         <mrow>                                              <mi>c</mi>  </mrow>   # this one does not have the '='

sub atop_aligned
  { my $align= shift; 
    #warn "atop with j3j format, content: ", dump_items( @_), "\n";
    my $mtable= mtable( { columnalign => $align });
    foreach my $mtr ( @_)
      { #warn "new ", $mtr->tag, "\n";
        if( $mtr->is( 'mrow'))
          { my( @before_mo, $mo, @after_mo);
            $mtr->set_tag( 'mtr');
            foreach my $child ($mtr->children)
              { #warn "  child is ", $child->tag, "(content: ", $child->text_only, ")\n";
                $child->cut;
                # the operator to align on is he first comparison <mo>
                # this is NOT the right way to do this, the <mo> should be found through parsing, not its text
                # TODO: use the #from from the mo to see if it's a comparison operator
                if( $child->is( 'mo') && ! $mo && $is_comp{$child->text})
                  { $mo= $child; $child; }
                elsif( $mo)
                  { push @after_mo, $child; $child; }
                else
                  { push @before_mo, $child; $child; }
              }

            if( $mo) # found an mo, all 3 cells are filled 
              { $mtr->set_content( mtd( @before_mo), mtd( $mo), mtd( @after_mo)); }
            else     # no mo, first 2 cells are empty, everything goes in the 3rd one
              { $mtr->set_content( mtd(), mtd(), mtd( @before_mo)); }

            $mtr->paste( last_child => $mtable);
          }
        else
          { # the entire row is a single element (often an mtext)
            # which means that an mtr should be created, with the element in the 3rd cell (to align it)
            my $row= mtr( mtd(), mtd(), mtd( $mtr));
            $row->paste( last_child => $mtable);
          }

      }
    return $mtable;
  }

# TODO: it looks like the MathML implementors would prefer not to have to deal with mfenced, but replace it
# with stretchy mo's (at least the browser guys) so either go with that or give the user the choice 
sub wrap
  { my( $open, $close, $exp)= @_;
    #warn "wrap: open: '$open' - close: '$close' - exp: '$exp'\nreturned: ",  mrow( mo( $open), $exp, mo( $close)), "\n";
    return mfenced( { sep => [ $open, $close, ','] }, $exp); 
    #return mrow( mo( $open), $exp, mo( $close)); 
  }

sub pre_op
  { my $op= shift;
    return mrow( tag( mo => $op), @_);
  }

sub post_op
  { my( $exp, $op)= @_;
    return mrow( $exp, mo($op));
  }


# those nodes require the format, it will be passed as the first argument to the sub
# TODO: this smells, I think the proper way would be to pass around objects that hold
# a list of XML elements, the format and maybe other info (from?) instead of the current
# way of passing elements (usually one but sometimes more, and the format only when needed) 
my %need_format= map { $_ => 1 } ( qw( atop diacritical id lparen matrix rparen sn ), keys %large);

# now we generate the big dispatcher, from specials and the various categories of nodes
sub init_node_dispatcher
  { my $dp={ %special};
    foreach my $node (@lit)                   { $dp->{$node}= sub { mrow( mo( $node), shift()); }; }
    while( my( $node, $op) = each %pre_op)    { $dp->{$node}= sub { pre_op( $op, @_); };           }
    while( my( $node, $op) = each %post_op)   { $dp->{$node}= sub { post_op( $_[0], $op); };       }
    while( my( $node, $brackets) = each %wrap){ $dp->{$node}= sub { wrap( @$brackets, @_); };      }
    while( my( $node, $op)= each %nary)       { $dp->{$node}= sub { return op( $op, @_); };    }
    while( my( $node, $symbol)= each %large)  { $dp->{$node}= sub { sum( $symbol => @_); };        }
    return $dp;
  }

my $dp=init_node_dispatcher();

sub lparen
  { my $format= shift;
    my @lparen=( '(', '[', '{');
    my( $paren_type)= $format->{i};
    $paren_type||=0;
    pre_op( $lparen[$paren_type], @_);
  }

sub rparen
  { my $format= shift;
    my @rparen=( ')', ']', '}');
    my( $paren_type)= $format->{i};
    $paren_type||=0;
    post_op( @_, $rparen[$paren_type]);
  }

sub tag
  { my $tag= shift;
    my $atts= $_[0] && ref( $_[0]) && ref( $_[0]) eq 'HASH' ? shift : {} ;

    # if next arg is an arrayref expand it, add to args
    if( @_)
      { return pelt->new( $tag => $atts, flatten( @_)); }
    else
      { return pelt->new( $tag => $atts)->set_empty( 1); }
  } 


sub op  { my $op= shift; return mrow(shift, map { (mo($op), $_) }  @_);  }
#sub opi { my $op= shift; return mrow(shift, map { (moi($op), $_) } @_); }
sub moa { return tag( mo => { accent => 'true' }, @_); }
sub moi { return tag( mo => { mathvariant => 'italic' }, @_); }

sub mrows { return [ map { mrow( $_) } @_ ]; }

BEGIN 
  { foreach my $elt (qw( mo mi mn mtext msup msub mfrac mover mroot munder msqrt mspace mtable mtr mtd mmultiscripts mpadded))
      {  no strict 'refs';
        *{$elt}= sub { tag( $elt => @_); };
      }
  }

sub none        { return tag( 'none');        }
sub mprescripts { return tag( 'mprescripts'); }

sub mrow
  { 
    my $atts= $_[0] && ref( $_[0]) && ref( $_[0]) eq 'HASH' ? shift : {} ;

    # do some merging, of consecutive strings and empty mo's
    my @content;
    foreach my $content (flatten( @_))
      { if( ! @content) { push @content, $content; next; }
        my $prev= $content[-1];
        if( $content->is( 'mtext') && $prev->is( 'mtext')) 
          { my $ptext= $prev->text;
            my $ctext= $content->text;
            # cautiously add a space between the 2 merged mtext
            # heuristic: add a space unless it looks like the 2 texts should be merged without one
            # ie one of the border characters is '_', ',' a digit or '-'
            if( $ptext !~ m{[_,0-9-]$} && $ctext !~ m{^[_,0-9-]})
              { $prev->suffix( ' ' . $content->text); }
            else
              { $prev->suffix( $content->text); }
          }
        elsif( $content->is( 'mo') && $content->text eq ' ' && $prev->is( 'mtext'))
          { $prev->suffix( $nbsp);
            push @content, $content;
          }
        elsif( $prev->is( 'mo') && $prev->text eq ' ')
          { $content->prefix( $nbsp);
            pop @content;
            push @content, $content;
          }
        else
          { push @content, $content; }
      }

    my $mrow= tag( mrow => $atts => @content);
    if( $mrow->has_no_atts && ($mrow->children()==1)  && $mrow->first_child->is( 'mrow|mn|mi'))
      { return $mrow->first_child; }
    return $mrow;
  }
     

sub mfenced
  { my %atts;
    my @att_names= qw(open close separators);
    if( $_[0] && ref( $_[0]) eq 'HASH' && $_[0]->{sep})
      { @atts{@att_names}= @{shift()->{sep}}; }
   
    my $tag= 'mfenced';
    #warn "checking children\n";
    if( ! $_[0])
      { foreach my $child (flatten( @_) )
        { #warn "  child: ", $child->tag, " n: ", $child->format('n'), " child is ", $child->sprint, "\n"; 
            if( UNIVERSAL::isa( $child, 'pelt') && $child->format( 'n')) 
              { # warn "no fencing\n"; 
                $tag='mrow'; 
                %atts=(); 
                last;
              } 
          } 
      }
    return tag( $tag => \%atts, @_);
  }

sub extract_separators_from_mfenced
  { my( $mfenced)= @_;
    my @children= $mfenced->children;
    my @esep; # separators, to be deleted if they can be replaced by the separator attribute
    my $sep;
    while( @children)
      { shift @children;                  # skip a child
        if( my $esep= shift @children)    # next one should be a mi containing the separator
          { if( $esep->tag ne 'mi') 
              { return; }                 # failed, not a mi
            if( ! defined $sep)
              { $sep= $esep->text;        # first separator found, store it to see if they are all alike 
                push @esep, $esep;        #  store the element so we can remove it later
              }
            else
              { if( $esep->text ne $sep)
                  { return; }             # failed: 2 different separators found
                else
                  {  push @esep, $esep; } # still good, store the element so we can remove it later
              }
          }
      }
    if( ! defined $sep) { return; } # no separator, just 1 element in mfenced

    # if we get here, we have a success
    $mfenced->set_att( separators => $sep);     # set attribute
    foreach my $esep (@esep) { $esep->delete; } # remove elements
  }


sub msubsup    { return tag( msubsup => mrows(@_));    }
sub munderover { return tag( munderover => mrows(@_)); }

sub id
  { my $format= shift;
    my $bracket= { 2 => [ '{', '}' ],
                   1 => [ '[', ']' ],
                 };
    my $atts= { separators => '' };
    my( $bracket_type)= $format->{i};
    if( $bracket->{$bracket_type})
      { $atts->{open}  = $bracket->{$bracket_type}->[0]; 
        $atts->{close} = $bracket->{$bracket_type}->[1]; 
      }
    return tag( mfenced => $atts => @_);
  }

sub u_or_n_nary
  { my $op= shift;
    if( @_ == 1) { return mrow( mo( $op), $_[0]); }  # unary form
    else         { return op( $op =>   @_);       }  # n-ary form
  }

sub sum
  { my( $glyph, $format, $content, $from, $to)= @_;
    my $int;
    if( defined( $from) && defined( $to))
      { if( $format->{i} == 1) # todo : use attributes to position better
          { $int= msubsup( mo( $glyph), mrow( $from), mrow( $to)); } 
        elsif( $format->{i} == 2) 
          { $int= msubsup( mo( $glyph), mrow( $from), mrow( $to)); } 
        else
          { $int= munderover( mrow( mo( $glyph)), mrow( $from), mrow( $to)); } 
      }
    elsif( defined( $from))
      { if( $format->{i} == 1) # todo : use attributes to position better
          { $int= munder( mo( $glyph), mrow( $from)); } 
        elsif( $format->{i} ==  2) 
          { $int= munder( { accent => 'true' }, mo( $glyph), mrow( $from)); } 
        else
          { $int= munder( mrow( mo( $glyph)), mrow( $from)); } 
      }
    else
      { $int= mo( $glyph); }

    # if there is no format, then take more space (i1i and i2i both imply "use less space")
    my $displaystyle= $format->{i} ? {} : { displaystyle => 'true' }; 

    return mrow( $displaystyle, $int, $content);
  }

sub indexes
  { my( $nb_sup, $nb_sub)= (shift(), shift());
    my $base= shift();
    my @sub= splice( @_, 0, $nb_sub);  
    my @sup= @_;
    if( @sub && @sup)
      { return msubsup( $base, mrow( @sub), mrow( @sup)); }
    elsif( @sub)
      { return msub( $base, mrow( @sub)); }
    elsif( @sup)
      { return msup( $base, mrow( @sup)); }
  }

sub chem
  { my( $pre_sub, $post_sub, $pre_sup, $post_sup)= (shift(), shift(), shift(), shift());

    my $exp= shift();

    # order of the indexes: pre_sup, post_sup, pre_sub, post_sub
    my @pre_sup = $pre_sup  ? splice( @_, 0, $pre_sup  ) : ();
    my @post_sup= $post_sup ? splice( @_, 0, $post_sup ) : ();
    my @pre_sub = $pre_sub  ? splice( @_, 0, $pre_sub  ) : ();
    my @post_sub= $post_sub ? splice( @_, 0, $post_sub ) : ();

    if( @_) { die "wrong content for chem element\n", Dump( \@_), "\n"; }

    # math ml wants first pairs of post sub/sup (with none as filler)
    #               then a mprescripts separator
    #               then pairs of pre sub/sup (with none as filler)

    my @indexes;
    while( @post_sub || @post_sup)
      { push @indexes, shift( @post_sub) || none();
        push @indexes, shift( @post_sup) || none();
      }
    if( @pre_sub || @pre_sup)
      { push @indexes, mprescripts(); 
        while( @pre_sub || @pre_sup)
          { push @indexes, shift( @pre_sub) || none();
            push @indexes, shift( @pre_sup) || none();
          }
      }
    return mmultiscripts( $exp, @indexes);
  }

sub tensor
  { my( $positions, $exp)= (shift(), shift());
    my @indexes;
    foreach my $index (@_)
      { my $sup= $positions % 2;
        $positions= int( $positions / 2);
        if( $sup)
          { push @indexes, none(), $index; }
        else 
          { push @indexes, $index, none(); }
      }
    return mmultiscripts( $exp, @indexes);
  }

sub matrix
  { my $format= shift;
    my( $rows, $columns)= (shift, shift);
    #warn "in matrix ($rows, $columns)\n";
    my @rows;
    foreach (1..$rows) 
      { push @rows, mtr( map { mtd( $_) } splice( @_, 0, $columns)); }
    my $matrix= mtable( @rows);
    if( $format->{i} != 1) { $matrix= mfenced( { sep => [ '[',']' ] }, $matrix); }
    return $matrix;
  }


      
sub single_char
  { my ($item)= @_;

    my( $char, $decoration)= $item=~ m{^([^,]*)((?:,[0-4])*)$};
    #warn "in tchar: item = [$item] (decoration is [$decoration]\n" if $decoration;
    
    my $ent; # true if the character is an entity
    if( length( $char) > 1 && $ent{$char})
      { $ent= 1;
        $char= $ent{$char};
      }

    my $mi= tag( mi => $char);

    if( $decoration) 
      { $decoration=~ s{^,}{};
        my @decoration= split /,/, $decoration;
        return decoration( @decoration, $mi); 
      }
    else            
      { return $mi; }
  }

sub diacritical
  { my $format= shift;
    my $exp= decoration( @_);
    # $_[3] is bar (it's 1 when the decoration is an overbar)
    if( $_[3] == 1 && $format->{t} && ( ($format->{t} / 65536) < -1.8) )
      { my $mi= $exp->first_descendant( 'mi');
        if( $mi)
          { my $c = $mi->text;
            if( my $stroke= $with_stroke{$c})
              { $mi->next_sibling->cut;
                $mi->set_text( $stroke);
                if( $mi->parent->parent) 
                  { $mi->parent->unwrap; }
                else
                  { $exp= $mi; }
                warn "inserted [$stroke]\n" if $::opt{v};
              }
          }
      }
    return $exp;
  }

sub decoration
  { my( $vector, $prime, $dot, $bar, $underscore, $exp)= @_;
    # for now several decorations on the same expression are not specialcased (no munderover for example)
    if( $vector==1)     { $exp= mover( { accent => 'true' }, $exp, moa('â‡€'));  }
    if( $vector==2)     { $exp= mover( { accent => 'true' }, $exp, moa( '^')); }
    if( $vector==3)     { $exp= mover( { accent => 'true' }, $exp, moa( '~')); }
    if( $vector==4)     { $exp= mover( { accent => 'true' }, $exp, moa( 'â†’')); }
    if( $vector==5)     { $exp= mover( { accent => 'true' }, $exp, moa( 'â€')); }
    if( $prime==1)      { $exp= mrow(  $exp, moa( $ent{prime}));    }
    if( $prime==2)      { $exp= mrow(  $exp, moa( $ent{pprime}));   }
    if( $prime==3)      { $exp= mrow(  $exp, moa( $ent{tprime}));   }
    if( $dot==1)        { $exp= mover( $exp, moa( $ent{dot}));      } 
    if( $dot==2)        { $exp= mover( { accent => 'true' }, $exp, mo( $ent{twodots}));  } 
    if( $dot==3)        { $exp= mover( { accent => 'true' }, $exp, mo( $ent{ellip}));    } 
    if( $bar==1)        { $exp= mover( { accent => 'true' }, $exp, mo( $ent{overline})); }
    if( $underscore==1) { $exp= munder( { accentunder => 'true' }, $exp, mo('~'));            }
    if( $underscore==2) { $exp= munder( { accentunder => 'true' }, $exp, mo('_'));            }
    return $exp; 
  }

sub offset_tweak
  { my( $m, $offset)= @_;
    #warn "processing offset '$offset' for '$m'\n";
    my $points= $offset/65536;
    if( $points > 0)      # boundaries are guessed
      { return mrow( msub( mi(''), $m)); }
    elsif( $points >= -6 && $points <= -3)
      { return mrow( msup( mi(''), $m)); }
    else
      { my $pt= int( $points); # so display is nicer
        warn "cannot process y offset $offset ($pt pt)\n"; 
        return $m;
      }
  }

sub parse_format
  { my( $format_token)= @_;

    return if ! $format_token || ! $format_token->[0];

    my $format={ original => $format_token }; # store the initial string for debugging purposes

    my $format_string= $format_token->[0]; # that's where Parse::RecDescent puts the format string

    # metrics would need to be processed differently I think
    while( $format_string=~ s{^([Mmnuv]|([AcCDijNoORSU])\d+\2|([BfqTVW])"[^"]*"\3|([s])[\d.]*\4|([blrtxyZ])-?[\d.]*\5)}{})
      { my $format_part= $1; 
        if( length( $format_part) == 1)
          { $format->{$format_part}= 1; } # single letter format
        else
          { my $type= substr( $format_part, 0, 1); 
            # remove the format code (first and last char) and surrounding quotes if present
            my $val= $format_part;
            $val=~ s{^(.)(.*?)\1$}{$2};
            $val=~ s{"(.*)"}{$1};
            # from the previous version of the code it looks like some metrics values can be repeated
            # need to investigate
            if( $type && $format->{type} && $val =~ m{^-?[\d.]+$})
              { $format->{$type} += $val; }
            else
              { $format->{$type} = $val; }
          }
      }
    #warn "format: [$format_token->[0]] parsed as ", join( ', ', map { "$_ => $format->{$_}" } sort keys %$format), "\n";
    return $format;
  }

sub m_to_pt
  { my $m= shift;
    my $pt= int($m/65536);
    if( $pt >= 0) { return "+$pt" . "pt"; }
    else          { return $pt . "pt";    }
    return $pt;
  }

sub apply_format
  { my $format= shift;
    my @e= @_;

    # formats that apply to the single element that's being passed 
    if( exists $format->{C})         { if( $format->{C}) { uc_content( @e); }  
                                       else              { lc_content( @e); }
                                     } 

    my $mathvariant= mathvariant( $e[0], $format);
    #warn "mathvariant: $mathvariant\n" if $mathvariant;
    $e[0]->set_att( mathvariant => $mathvariant) if $mathvariant;

    # only apply fine-grained positioning formats if opt{F} on
    if( $::opt{F})
      { # positioning, wrap in mpadded
        my $padding_atts;
        if( my $bspace  = $format->{b})  { $padding_atts->{voffset} = m_to_pt( $bspace ); }
        if( my $lspace  = $format->{l})  { $padding_atts->{lspace}  = m_to_pt( $lspace ); }
        if( my $rspace  = $format->{r})  { $padding_atts->{width}   = m_to_pt( $rspace);  }
        # x and y are kerning, but seem to be used for spacing 
        # todo: experiment with style="letter-spacing:$rspace" for x and maybe style/padding for both
        if( my $xkern  = $format->{x})   { $padding_atts->{width}   = m_to_pt( $xkern);   }
        if( my $ykern  = $format->{y})   { $padding_atts->{height}  = m_to_pt( $ykern);   } 
        if( $padding_atts)
          { # warn "padding!\n";
            foreach my $att ( keys %$padding_atts) 
              { if( $padding_atts->{$att} eq "+0pt") { delete $padding_atts->{$att}; } # remove padding that turns out to be 0
              }
            if( keys %$padding_atts)
              { $e[0] = mpadded( $padding_atts, $e[0]); }
          }
      }

    
    # formats that add elements, should be after the previous rules
    if( $format->{v})                { push @e, tag( mspace => { linebreak => "newline" }); }

    

    $_->set_format( $format) foreach @e; # so it can be accessed later

    return @e > 1 ? [@e] : $e[0];
  }


sub mathvariant
  { my( $e, $format)= @_;
    my $text           = $e->text_only;
    my $tag            = $e->tag;
    my $special        = $is_ent{$text} ? 1 : 0;
    my $single_char    = $tag eq 'mi' && length $text == 1 && ! $special; # defaults to 'italic'
    my $special_char   = $tag eq 'mi' && length $text == 1 &&   $special; # not italicized by default
    my $string         = ! $single_char && ! $special_char;

    #warn "tag: [$tag] text: [$text] special: $special single_char: $single_char special_char: $special_char\n  ", dump_format( $format), "\n";
    #warn " from: ", $e->from, "\n";

    # some generated elements do not need a mathvariant, the format applies to the main element, not them
    # the call to math variant could be avoided but I found it easier to do it here
    return if $tag eq 'mo';

    # set the defaults in mif
    #warn "in $tag, [$text] format->{B}: [$format->{B}]\n";
    if( $single_char && ! $format->{B}) { $format->{B}= "Italic"; };

    my $font_type = font_type( $format->{f}); # many different. Regular is ''
    my $bold      = bold(      $format->{W}); # 'bold' or ''
    my $italic    = italic(    $format->{B}); # 'italic' or ''

    #warn "  font_type: [$font_type] - bold: [$bold] - italic: [$italic]\n";

    # first let's deal with cases that depend on the nature of the string
    # mif with no format generates italic for single char (not special char) and normal otherwise
    # mml with no mathvariant generates italics for single char (including special char) and normal otherwise
    # so with no font_type or bold we have to adjust this
    if( ! $font_type && ! $bold)     
      { if( ($single_char || $special_char) && ! $italic)
          { return 'normal' }
        elsif(    ( $single_char  &&   $italic)
               || ( $special_char &&   $italic)  # mif special char + italic is mml default
               || ( $string       && ! $italic)
             )
          { return ''; }
      }

    # now we don't care about the type of character anymore 

    # the rules for building the mathvariant value are weird enough that 
    # it has to be this giant if/elsif monster

    if( ! $font_type)
      { if(    $bold && $italic) { return 'bold-italic';   }
        elsif( $bold)            { return 'bold';          }
        elsif( $italic )         { return 'italic';        }
      }

    # these 2 don't allow bold/italic
    if( $font_type eq 'monospace' || $font_type eq 'double-struck') 
      { return $font_type; }

    # these 2 only allow bold
    if( $font_type eq 'fraktur' || $font_type eq 'script') 
      { if( $bold) 
          { return join '-', 'bold', $font_type; }
        else
          { return $font_type; }
      }

    # and this one allows bold and italic but the naming is all verkakte
    if( $font_type eq 'sans-serif')
      { if( $bold && $italic) { return 'sans-serif-bold-italic'; }
        elsif( $bold)         { return 'bold-sans-serif';        }
        elsif( $italic  )     { return 'sans-serif-italic';      }
        else                  { return 'sans-serif';             }
      }
  }

sub uc_content
  { foreach my $e ( @_)
      { foreach ($e->descendants( '#TEXT')) { $_->set_text( uc( $_->text)); } }
  }
sub lc_content
  { foreach my $e ( @_)
      { foreach ($e->descendants( '#TEXT')) { $_->set_text( lc( $_->text)); } }
  }

sub replace_frame_escapes
  { my( $s)= @_;
    $s=~ s{\\(x[0-9a-f][0-9a-f] |.)}{ if( $frame_escape{$1}) 
                                        { $1 }
                                      else
                                        { my $code= $1;
                                          if( $code > 0x07) { chr hex $1; }
                                          else             { '';          }
                                        }
                                    }eg;
    $s=~ s{""}{"}g;
    return $s;
  }

# heuristic at work!
# we have to try to assign the font to one of the MathML supported type, regular, sans-serif, script, double-struck, fraktur, monospace
# for now we do this based on a heuristic on the name of the font 
# we can't be sure the font even exists on the machine doing the conversion
# we could use a table that would do this. I haven't had to do this so far
sub font_type
  { my $font= shift || '';
   
    if(    $font=~ m{courier|mono}i)                 { return 'monospace';     }
    elsif( $font=~ m{(arial|verdana|sans)}i)         { return 'sans-serif';    }
    elsif( $font=~ m{(euf[mb]|frak|got(hic|ik))}i)   { return 'fraktur';       }
    elsif( $font=~ m{(eus[mb]|script)}i)             { return 'script';        }
    elsif( $font=~ m{(msbm)}i)                       { return 'double-struck'; }
    else                                             { return '';              } # regular is the empty string
  }

sub bold
  { my $weight= shift || '';
    if( $weight eq 'Bold' or $weight eq 'Medium') { return 'bold'; }
    else { return ''; }
  }

sub italic
  { my $angle= shift || '';
    if( $angle eq 'Italic' or $angle eq 'Obliqued') { return 'italic'; }
    else { return ''; }
  }

sub flatten { map { ref $_ eq 'ARRAY' ? flatten(@$_) : $_ } @_ }

# a couple of dump subs used in debugging
sub dump_format { my $format=shift; return "[$format->{original}] => ", join ', ', map { "$_=[$format->{$_}]" } sort keys %$format; }
sub dump_items  { return join( "\n====\n", map { UNIVERSAL::isa( $_, 'pelt') ? "[elt (" . $_->_dump( { depth => 2 }) . ")]\n" : "[$_]\n" } flatten( @_)); }


}

# the grammar itself 

exp  : ( node | string | num | char | ind |tnum | <error?> <reject>)          { $return= $item[1]; 1; }
node : ident '[' format(?) exp(s /,/) ']'           { my $node_type= $item{ident}; #/ (so vim syntax-highlighter does not get confused)

                                                      my $node= $dp->{$node_type};
                                                      if( !$node) { warn "unknown node type: $item{ident}\n"; }
                                                      # warn "node: $item{ident}\n";

                                                      my $format= parse_format( $item{'format(?)'});

                                                      # if the node handler needs the format, it's the 1st arg
                                                      my @args=  $need_format{$node_type} ? ( $format) : ();
                                                     
                                                      push @args, @{$item[4]};

                                                      $return= $node->(@args);
                                                      
                                                      foreach my $r (flatten( $return)) { $r->set_from( $node_type); }

                                                      $return= apply_format( $format, $return); 
                                                     
                                                      1;
                                                    }
string  : 'string' '[' format(?) '"' tstring '"' ']' { my $string= replace_frame_escapes( $item{tstring});
                                                       $string=~ s{ }{$nbsp}g;

                                                       $return= mtext( $string);
 
                                                       my $format= parse_format( $item{'format(?)'});
                                                       $return= apply_format( $format, $return);  
                                                       1;
                                                      }
num     : 'num' '[' format(?) tnum ',' '"' tstring '"' ']' { $return= mn( $item{tstring});    
                                                             my $format= parse_format( $item{'format(?)'});
                                                             if( $format->{y}) { $return= offset_tweak( $return, $format->{y}); }
                                                             apply_format( $format, $return); 
                                                             #warn "in num rule: num: [$item{tstring}], format: ", dump_format( $format), ", return: ", $return->sprint, "\n";
                                                             1;
                                                         }
char    : /(char|dummy)/ '[' format(?) tchar  ']'     { $return= $item{tchar};

                                                        my $format= parse_format( $item{'format(?)'});

                                                        # this could probably be done in apply_format
                                                        if( my $font= $format->{f})           
                                                          { if( $font eq 'Symbol') # replace the character
                                                              { $return->set_text( join '', map { $symbol{$_} || $_ } split //, $return->text); }
                                                          }

                                                        $return= apply_format( $format, $return);

                                                        # in some cases (decorations) what's returned is not a single element but a (small) tree
                                                        # eg an mrow with the char and an accent
                                                        # the format needs to be applied to the sub elements (because of single chars rules about special/non-special chars) 
                                                        foreach my $e ( map { $_->descendants( '#ELT') } flatten($return))
                                                          { # warn "before applying format ", dump_format( $format), "to [", $e->sprint, "]\n";
                                                            my $tmp= $e->insert_new_elt( after=> 'tmp');
                                                            $e->cut;
                                                            $e= apply_format( $format, $e); # apply_format can return either a single element or (rarely) an arrayref of elements
                                                            foreach my $ne (flatten( $e))
                                                              { $ne->move( before => $tmp); }
                                                            $tmp->cut;
                                                            #warn "    return: [", $return->sprint, "]\n";
                                                          }
                                                        # warn "returning '$return' for char"; 
                                                        1;
                                                      }
ident   : /\w+/             { $return= $item[1]; 1; }
tnum    : /[+-]?\d+(\.\d+)?/   { $return= $item[1]; 1; }
tchar   : /[^\]]*/          { $return= single_char( $item[1]);   1; }
ind     : /\d+/             { $return= $item[1]; 1; } # a simple number, used for indices, matrix dimensions...
format  : '(*' /[^*]*/ '*)' { $return= $item[2]; 1; }
tstring : <skip:"">/[^"]*/<skip:$item[1]>           { $return= $item[2]; 1; } # need to change skip so we don't skip over whitespaces 
                                                                              # so vim syntax highlighter doesn't get confused: "
G

my $parser = Parse::RecDescent->new( $grammar) or die "Bad grammar!\n";

foreach my $file (@ARGV)
  { if( $file !~ m{\.mif$}) { next; }
    if( $opt{c} && -f filename( mml => $file)) { next; }

    if( $opt{v}) { warn "processing $file\n"; }

    my $mif= slurp( $file);
    $mif= clean_up_mif( $mif);
    warn "mif: $mif\n" if $opt{v};
    if( ! $mif) 
      { if( $opt{v}) { warn "$file not an equation, skipping.\n"; }
        next;
      }
    my $mml_content= $parser->exp( $mif);
    if( ! $mml_content)
      { my $warning= "could not parse mif\n";
        if( $opt{s}) { die  $warning; }
        else         { warn $warning; }
        next;
      }

    if( ref $mml_content eq 'ARRAY')
      { # case where the entire expression results in more than 1 element
        # I have seen this when the top frame statement has a *v* format that generates an extra mspace
        # so let's special case this here, since we can't know about it insode the parser

        my @mml= @$mml_content;

        # remove leading or trailing mspace (this should be enough to get back to a single element)
        if( $mml[0]->is( 'mspace'))  { shift @mml; }
        if( $mml[-1]->is( 'mspace')) { pop   @mml; }

        if( @mml == 1) { $mml_content= shift @mml; }
        else           { $mml_content= pelt->new( mrow => @mml); } # but if we still have more than 1 element, wrap in mrow
      }
        
    my $root= pelt->new( math => { xmlns => "http://www.w3.org/1998/Math/MathML", mathbackground => "transparent",  displaystyle => "true" }, $mml_content);
    my $mml= XML::Twig->new( pretty_print => $opt{i} || 'indented')->set_root( $root);

    # add the comment if needed
    if( $opt{C}) { $root->first_child->set_extra_data( "<!-- $opt{C} -->\n") if $root->first_child; }

    $mml->print_to_file( filename( mml => $file));
    if( $opt{v}) { warn "mml in ", filename( mml => $file), "\n"; } 
  }

# extract just the equation from the whole file (it can include all sorts of FrameMaker context)
sub clean_up_mif
  { my( $mif)= @_;
    my $clean_mif= $mif;
    if( $mif=~ m{<MathFullForm `([^']*)'\s*> # end of MathFullForm})
      { $clean_mif= $1; }

    $clean_mif=~ s{[\r\n]}{}g; # deal with files from various OSs by throwing away all (useless!) line returns
    # TODO: this may not be the right place to do this
    $clean_mif=~ s{prompt\[\s*(\([^)]*\))?\s*\]}{'char[' . ( $1 && $prompt{$1} ? $prompt{$1} : ' ') . ']'}eg; # hack, replace prompt by ' ' or 'â‹®'

    return $clean_mif;
  }

sub slurp
  { my $file= shift;
    open( my $in, '<', $file) or die "cannot open input file '$file': $!\n";
    local undef $/;
    my $content= <$in>;
    return $content;
  }

sub filename
  { my( $ext, $file)= @_;
    $file=~ s{\.[^.]+$}{.$ext};
    return $file;
  }


# the elements that are built are XML::Twig::Elt
# I just add a few convenience methods here
package pelt;
use XML::Twig;
use base 'XML::Twig::Elt';

sub new
  { my $t= shift;
    return bless $t->SUPER::new( @_);
  }

# return the value of a format (if the code argument is given), or the entire format hash
# if in debugging mode (-D option used) the data-format attribute is set on the element
# to help figure out what's going on
sub format
  { my( $elt, $code)= @_;
    my $format= $elt->att( '#format') || {};
    return $code ? $format->{$code} : $format;
  }

sub set_format
  { my $elt= shift;
    my $format= shift || {};
    $elt->set_att( 'data-format' => join ', ', map { "$_: [$format->{$_}]" } keys %$format) if $opt{D};
    return $elt->set_att( '#format' => $format);
  }

# tracks which mif statement generated the element
sub from     
  { return $_[0]->att( '#from'); }

# if in debugging mode (-D option used) the data-from attribute is set on the element
sub set_from 
  { my( $elt, $from)= @_;
    $elt->set_att( 'data-from', $from) if $::opt{D}; 
    return $elt->set_att( '#from', $from); 
  }

# returns the element if it was created from any of the statements passed in arguments
# false otherwise
# used to pass info up in the parsing process (some statement should generate different
# output depending on the context, which is not available while they're being parsed)
sub from_in
  { my $elt= shift;
    foreach my $from (@_)
      { if( $elt->from && $elt->from eq $from) { return $elt; } }
    return 0;
  }

1;

package main;
__END__
=head1 NAME

  mif2mml - converts MIF equations into MathML 

=head1 OPTIONS

  -c  only converts if the MathML file (.mml) does not exist already

  -C  comment, to add to the beginning of the file

  -F  formating, uses formating-specific Frame info (padding, spacing...)
      this usually leads to extra mark-up, like <mpadded> elements, but
      lower quality results (MathML renderers do a good job on their own,
      the additional formating interferes with it)

  -v verbose

  -D debug adds debugging attributes to the mml elements 
     - data-format for the Frame format and 
     - data-from   for the frame construct an element comes from

  -i <indent_type> changes the result identation, 'none' or 'indented' (default)

=head1 REQUIREMENTS

  - Perl 5.8+, perl modules XML::Twig and Parse::RecDescent

  - expat 

  -  mathmlsvg (from gtkmathview http://helm.cs.unibo.it/mml-widget/
     there are debian packages for libgtkmathview in sid
     
     alternatively you could use math2svg (L<http://www.grigoriev.ru/svgmath/>) for SVG generation

     those 2 packages are hell to install and configure, especially to get
     the fonts right

  - inkscape for PNG generation (from the SVG, so you also need gtkmathview or math2svg)


=head1 SEE ALSO

MIF Reference Online Manual: L<http://www.adobe.com/devnet/framemaker/pdfs/MIF_Reference.pdf>

=head1 AUTHOR

Michel Rodriguez <mirod@cpan.org>
Bug reports and feature requests should be emailed directly to the author.

=head1 LICENSE

 This program is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License verion 2.0,
 as published by the Free Software Foundation.

 This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details at
 L<http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt>

