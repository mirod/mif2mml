#!/usr/bin/env perl

use strict;
use warnings;

use utf8::all; # lots of funky chars in here

use Getopt::Std;

our %opt;
getopts( 'nspvceC:Di:', \%opt);

if( $opt{p}) { $opt{s}=1; }

#use XML::Twig;
import ptwig;
import pelt;

use Parse::RecDescent;
#$::RD_HINT=1;
$::RD_ERRORS = 1;
#$::RD_TRACE = 1;
use Unicode::UCD qw(charinfo);


# empirically found list of formats found in mif prompt[] with the corresponding character
# s10.00s generating 'â‹®' makes absolutley no sense, s normaly specifies the size of the character
# see https://help.adobe.com/en_US/framemaker/mifreference/mifref.pdf p 203
# I am probably missing something there...
my %prompt= ( '(*s10.00s*)' => 'â‹®');

my $grammar=<<'G';
{
my %ent=
    ( # p 182-184 of the MIF reference Manual
      aleph     => '×', alpha     => 'Î±', beta      => 'Î²', bot       => 'âŠ¥', chi       => 'Ï‡', cpartial  => 'âˆ‚',
      degree    => 'Â°', delta     => 'Î´', Delta     => 'âˆ†', emptyset  => 'âˆ…', epsilon   => 'Îµ', eta       => 'Î·',
      gamma     => 'Î³', Gamma     => 'Î“', Im        => 'ð”', infty     => 'âˆž', iota      => 'Î¹', kappa     => 'Îº',
      lambda    => 'Î»', Lambda    => 'Î›', ldots     => 'â€¦', mu        => 'Î¼', nabla     => 'âˆ‡', nu        => 'Î½',
      omega     => 'Ï‰', Omega     => 'Î©', phi       => 'Ï†', Phi       => 'Î¦', pi        => 'Ï€', Pi        => 'Î ',
      pprime    => 'â€³', prime     => 'â€²', psi       => 'Ïˆ', Psi       => 'Î¨', Re        => 'R', rho       => 'Ï',
      sigma     => 'Ïƒ', Sigma     => 'Î£', tau       => 'Ï„', theta     => 'Î¸', Theta     => 'Î˜', upsilon   => 'Ï…',
      Upsilon   => 'Î¥', varphi    => 'Ï†', varpi     => 'Ï€', varsigma  => 'Ï‚', vartheta  => 'Î¸', wp        => 'â„˜',
      xi        => 'Î¾', Xi        => 'Îž', zeta      => 'Î¶',
      # p 186-189 of the MIF reference Manual
      leq       => 'â‰¤', geq       => 'â‰¥', lessthan  => '<', notequal  => 'â‰ ', greaterthan => '>',
      infty     => 'âˆž', rarr      => 'â†’', caret     =>'â€¸', tprime    => 'â€´', rabracket => 'â€º', labracket => 'â€¹',
      tie       => 'â€', overline  => 'â€¾', dagger    => 'â€ ', geq       => 'â‰¥', leq       => 'â‰¤', sum       => 'âˆ‘',
      int       => 'âˆ«', dot       => 'â‹…', twodots   => 'â€¥', ellip     => 'â€¦', box       => 'â–¡', angle     => 'âˆ ',
      bullet    => 'â€¢', times     => 'â¨‰', exists    => 'âˆƒ', forall    => 'âˆ€', minusplus => 'âˆ“', plusminus => 'Â±',
      neg       => 'Â¬', therefore => 'âˆ´',
      topcurly  => 'ï¸·', bottomcurly => 'ï¸¸', 
    );

my %is_ent= map { $_ => 1 } values %ent;      

# to replace characters in the symbol font by the real character - from http://www.alanwood.net/demos/symbol.html
# I have only included greek characters, as they are the only ones I have seen used
my %symbol=
    ( a => 'Î±', b => 'Î²', c => 'Ï‡', d => 'Î´', e => 'Îµ', f => 'Ï†', g => 'Î³', h => 'Î·', i => 'Î¹', j => 'Ï•', k => 'Îº', l => 'Î›',  m => 'Î¼',
      n => 'Î½', o => 'Î¿', p => 'Ï€', q => 'Î¸', r => 'Ï', s => 'Ïƒ', t => 'Ï„', u => 'Ï…', v => 'Ï–', w => 'Ï‰', x => 'Î¾', y => 'Ïˆ', z => 'Î¶',
      D => 'Î”', F => 'Î¦', G => 'Î“', J => 'Ï‘', L => 'Î›', P => 'Î ', Q => 'Î˜', S => 'Î£',  U => 'Î¥', V => 'Ï‚', Y => 'Î¨', W => 'Î©', 
      O => 'Î©', # not sure about that
    );
# to replace escaped characters in strings or chars
my %frame_escape=
    ( t      => "\t", '>' => '>', q => "'", Q => '`', '\\' => '\\', # p 7 of the MIF reference Manual
      'xd0 ' => 'â€“',                                                # found this in an equation, don't know why d0 is a dash
    );

# nodes (operators in the MIF Reference)

# these types of node require specific processing
my %special=
  ( times => sub { mrow( @_); },
    id          => \&id,
    chem        => \&chem,  
    tensor      => \&tensor,  
    matrix      => \&matrix,  
    lparen      => \&lparen,
    rparen      => \&rparen,
    indexes     => \&indexes,
    diacritical => \&decoration,
    ast         => sub { mrow( msup( $_[0], mo('âˆ—'))); },
    box2        => sub { mrow( msup( mi($ent{box}), mi(2)), @_); },
    downbrace   => sub { mover( mrow( $_[0]), mo( $ent{topcurly})); },
    lap         => sub { mrow( msup( mi($ent{nabla}), mi(2)), @_); },
    overline    => sub { mover( shift(), mo( $ent{overline})); },
    upbrace     => sub { munder( mrow( $_[0]), mo( $ent{bottomcurly})); },
    acmut       => sub { mfenced( { sep => [ '{', '}', ','] }, @_); },
    bket        => sub { mfenced( { sep => [ 'ã€ˆ', 'ã€‰', '|'] }, @_); },
    cmut        => sub { mfenced( { sep => [ '[', ']', ','] }, @_); },
    inprod      => sub { mfenced( @_); },
    choice      => sub { mfenced( mfrac( { linethickness => 0 }, @_)); },
    function    => sub { my $func= shift; 
                         if( $func->from_in( qw(oppartial optotal)))
                           { mrow( $func, mrow( @_)); }
                         else
                           { mrow( $func, mfenced( @_)); }
                       },
    lim         => sub { munder( mrow( mo( 'lim'), shift()), mrow( shift)); },
    over        => sub { mfrac( mrows( @_));  },
    power       => sub { msup( mrows( @_));   },
    sn          => sub { my $format= shift;
                         if( $format->{i} == 1) { op( 'E', @_); }
                         else                   { mrow( shift(), mo( 'Ã—') , msup( mi(10), shift())); } 
                       },
    plus        => sub { # if next mo is a -, the + is not used
                         my @children= shift( @_);
                         foreach my $child (@_)
                           { if( ! $child->from_in( qw(minus mp pm)) )
                               { push @children, mo( '+'); }
                              push @children, $child;
                           }
                         return mrow( @children);
                       },
    minus       => sub { u_or_n_nary( '-'      => @_); },
    #diff        => sub { my $format= shift; my $op= $format->{n} ? 'âˆ‚' : 'd'; opi( $op, @_); },
    diff        => sub { mrow( moi( 'd'), @_); },
    dagger      => sub { return msup( @_, mo( $ent{dagger})); },
    grad        => sub { if( @_ == 1) { pre_op( 'âˆ‡', @_); }
                         else         { mrow( msub( mo('âˆ‡'), $_[1]), $_[0]); }
                       },

    log         => sub { if( @_ == 1) { pre_op( log => @_); }
                         else         { mrow( msub( mo('log'), $_[1]), $_[0]); }
                       },
    oppartial   => sub { if( @_ == 1) { mfrac( mrow( mo( 'âˆ‚')), mrow( mo('âˆ‚'), $_[0])); }
                         else         { mfrac( mrow( msup( mo( 'âˆ‚'), $_[1])), mrow( mo('âˆ‚'), mi( $_[0]))); }
                       },
    optotal     => sub { if( @_ == 1) { mfrac( mrow( mo( 'd')), mrow( mo('d'), $_[0])); }
                         else         { mfrac( mrow( msup( mo( 'd'), $_[1])), mrow( mo('d'), mi( $_[0]))); }
                   },
    sqrt        => sub { if( @_ == 1) { msqrt( @_); }
                         else         { mroot( @_); }
                       },
    substitution => sub { if(    @_ == 1) { post_op( shift(), '|'); }
                          elsif( @_ == 2) { msub( mrow( shift(), mo( '|')), shift()); }
                          else            { msubsup( shift(), mo( '|'), @_); }
                        },
    list  => sub { return mrow( @_); },

    # seems to be used instead of subsup: the expression, then atop for the sub and sup
    # so with 2 attributes we make it an mfrac, with more a 1-column matrix
    atop        => sub { #if( @_ == 2) 
                         #  { mfrac( { linethickness => 0 }, @_); }
                         #else
                         my $format= shift;
                         my $align= exists $format->{j} &&  $format->{j} == 0 ? 'center'
                                  : $format->{j} == 1                         ? 'left'
                                  : $format->{j} == 2                         ? 'right'
                                  :                                             'left';
                         my $class= $format->{j} >= 3 ? { class => 'align_on_equal' } : {};
                         mtable( { columnalign => $align }, map { mtr( $class, mtd($_)) } @_); 
                       },
  );


# p 186-194 of the MIF reference Manual

# these nodes are displayed as the name of the node followed by the content
my @lit= qw( acos acosh acot acoth acsc acsch arg asec asech asin atan atanh
             cos cosh cot coth csc csch exp imag ln real sec sech sgn sin sinh
             tan tanh
            );

# these nodes are displayed as a prefix ( different from the name of the node) followed by the content
# the data is <name> => <prefix>
my %pre_op= ( angle => 'âˆ ', box => 'â–¡', boxdot => 'â–¡â‹…',
              change => 'âˆ†', curl => 'âˆ‡â¨‰', 
              diver => 'âˆ‡â‹…', exists => 'âˆƒ', forall => 'âˆ€',
              mp => 'âˆ“', neg => 'Â¬', partial => 'âˆ‚', pm => 'Â±', 
              semicolon => ';', therefore => 'âˆ´', ucomma => ',', uequal => '=',
              var => 'Î´',
              
            ); 

# these nodes are displayed as the content wrapped between a prefix and a suffix
# the data is <name> => [ <prefix>, <suffix> ]
my %wrap = ( abs   => [ '|', '|' ], bra    => [ 'â€¹', '|' ],
             ceil  => [ 'âŒˆ', 'âŒ‰' ], dangle => [ '<', '>' ],
             floor => [ 'âŒŠ', 'âŒ‹' ], ket    => [ '|', 'â€º' ], 
             norm  => [ 'â€–'. 'â€–' ],                             # (sometimes!) appears as 1 bar in my editor, should be 2, alt: âˆ¥ 
           );

# these nodes are displayed as the content, followed by a suffix
# the data is <name> => <suffix>
my %post_op= ( fact => '!', );

# these nodes are displayed as the list of contents, separated by an operator
# data is <name> => <operator>
my %nary=( approx => 'â‰ˆ', cap => 'âˆ©', cdot => 'â‹…', comma => ',', cong => 'â‰…', cup => 'âˆª', equal => '=',
           equiv => 'â‰¡', geq => 'â‰¥', gg => 'Â»',  greaterthan => '>', in => 'âˆˆ',  jotdot => 'â—Š', 
           leftarrow => 'â†', Leftarrow => 'â‡', leq => 'â‰¤', lessthan => '<', ll => 'Â«',
           lrarrow => 'â†”', LRarrow => 'â‡”', ni => 'âˆ‹', notequal => 'â‰ ', notin => 'âˆ‰', notsubset => 'âŠ„',
           oplus => 'âŠ•', otimes => 'âŠ—', parallel => '||', perp => 'âŠ¥', propto => 'âˆ', rightarrow => 'â†’',
           Rightarrow => 'â‡’', sim => 'âˆ¼', subset => 'âŠ‚', subseteq => 'âŠ†', supset => 'âŠƒ', supseteq => 'âŠ‡',
           vee => 'âˆ¨', wedge => 'âˆ§',
           # binaries that can be processed as n-ary
           bullet => 'â€¢', cross => 'Ã—', div => 'Ã·', fract => 'â„'
         );

my %large=( bigcap => 'âˆ©', bigcup => 'âˆª', int => 'âˆ«', oint => 'âˆ«', prod => 'âˆ', sum => 'âˆ‘');

# those nodes require the format, it will be passed as the first argument to the sub
my %need_format= map { $_ => 1 } ( qw( atop id lparen matrix rparen sn ), keys %large);

sub wrap
  { my( $open, $close, $exp)= @_;
    #warn "wrap: open: '$open' - close: '$close' - exp: '$exp'\nreturned: ",  mrow( mo( $open), $exp, mo( $close)), "\n";
    return mfenced( { sep => [ $open, $close, ','] }, $exp); 
    #return mrow( mo( $open), $exp, mo( $close)); 
  }

sub pre_op
  { my $op= shift;
    return mrow( tag( mo => $op), @_);
  }

sub post_op
  { my( $exp, $op)= @_;
    return mrow( $exp, mo($op));
  }


sub init_node_dispatcher
  { my $dp={ %special};
    foreach my $node (@lit)                   { $dp->{$node}= sub { mrow( mo( $node), shift()); }; }
    while( my( $node, $op) = each %pre_op)    { $dp->{$node}= sub { pre_op( $op, @_); };           }
    while( my( $node, $op) = each %post_op)   { $dp->{$node}= sub { post_op( $_[0], $op); };       }
    while( my( $node, $brackets) = each %wrap){ $dp->{$node}= sub { wrap( @$brackets, @_); };      }
    while( my( $node, $op)= each %nary)       { $dp->{$node}= sub { return op( $op, @_); };    }
    while( my( $node, $symbol)= each %large)  { $dp->{$node}= sub { sum( $symbol => @_); };        }
    return $dp;
  }


my $dp=init_node_dispatcher();

sub lparen
  { my $format= shift;
    my @lparen=( '(', '[', '{');
    my( $paren_type)= $format->{i};
    $paren_type||=0;
    pre_op( $lparen[$paren_type], @_);
  }

sub rparen
  { my $format= shift;
    my @rparen=( ')', ']', '}');
    my( $paren_type)= $format->{i};
    $paren_type||=0;
    post_op( @_, $rparen[$paren_type]);
  }

sub tag
  { my $tag= shift;
    my $atts= $_[0] && ref( $_[0]) && ref( $_[0]) eq 'HASH' ? shift : {} ;

    # if next arg is an arrayref expand it, add to args
    if( @_)
      { return pelt->new( $tag => $atts, flatten( @_)); }
    else
      { return pelt->new( $tag => $atts)->set_empty( 1); }
    #return join '', "<$tag$atts>", @_, "</$tag>"; 
  } 


sub op  { my $op= shift; return mrow(shift, map { (mo($op), $_) }  @_);  }
sub opi { my $op= shift; return mrow(shift, map { (moi($op), $_) } @_); }
sub moa { return tag( mo => { accent => 'true' }, @_); }
sub moi { return tag( mo => { mathvariant => 'italic' }, @_); }

sub mrows { return [ map { mrow( $_) } @_ ]; }

BEGIN 
  { foreach my $elt (qw( mo mi mn mtext msup msub mfrac mover munder msqrt mroot mspace mtable mtr mtd mmultiscripts))
      {  no strict 'refs';
        *{$elt}= sub { tag( $elt => @_); };
      }
  }

sub none        { return tag( 'none');        }
sub mprescripts { return tag( 'mprescripts'); }
sub hspace      { return tag( mspace => { width  => "$_[0]pt"});  }
sub vspace      { return tag( mspace => { height => "$_[0]pt"}); }

sub mrow
  { my %atts;
    my $mrow= tag( mrow => @_);
    if( $mrow->has_no_atts && ($mrow->children()==1)  && $mrow->first_child->is( 'mrow|mn|mi'))
      { return $mrow->first_child;
      }
    return $mrow;
  }
     

sub mfenced
  { my %atts;
    my @att_names= qw(open close separators);
    if( $_[0] && ref( $_[0]) eq 'HASH' && $_[0]->{sep})
      { @atts{@att_names}= @{shift()->{sep}}; }
   
    my $tag= 'mfenced';
    #warn "checking children\n";
    foreach my $child (flatten( @_) )
      { #warn "  child: ", $child->tag, " n: ", $child->format('n'), " child is ", $child->sprint, "\n"; 
        if( UNIVERSAL::isa( $child, 'pelt') && $child->format( 'n')) 
          { # warn "no fencing\n"; 
            $tag='mrow'; 
            %atts=(); 
            last;
          } 
      }
    return tag( $tag => \%atts, @_);
  }

sub extract_separators_from_mfenced
  { my( $mfenced)= @_;
    my @children= $mfenced->children;
    my @esep; # separators, to be deleted if they can be replaced by the separator attribute
    my $sep;
    while( @children)
      { shift @children;                  # skip a child
        if( my $esep= shift @children)    # next one should be a mi containing the separator
          { if( $esep->tag ne 'mi') 
              { return; }                 # failed, not a mi
            if( ! defined $sep)
              { $sep= $esep->text;        # first separator found, store it to see if they are all alike 
                push @esep, $esep;        #  store the element so we can remove it later
              }
            else
              { if( $esep->text ne $sep)
                  { return; }             # failed: 2 different separators found
                else
                  {  push @esep, $esep; } # still good, store the element so we can remove it later
              }
          }
      }
    if( ! defined $sep) { return; } # no separator, just 1 element in mfenced

    # if we get here, we have a success
    $mfenced->set_att( separators => $sep);     # set attribute
    foreach my $esep (@esep) { $esep->delete; } # remove elements
  }


sub msubsup    { return tag( msubsup => mrows(@_));    }
sub munderover { return tag( munderover => mrows(@_)); }

sub id
  { my $format= shift;
    my $bracket= { 2 => [ '{', '}' ],
                   1 => [ '[', ']' ],
                 };
    my $atts= { separators => '' };
    my( $bracket_type)= $format->{i};
    if( $bracket->{$bracket_type})
      { $atts->{open}  = $bracket->{$bracket_type}->[0]; 
        $atts->{close} = $bracket->{$bracket_type}->[1]; 
      }
    return tag( mfenced => $atts => @_);
  }

sub u_or_n_nary
  { my $op= shift;
    if( @_ == 1) { return mrow( mo( $op), $_[0]); }  # unary form
    else         { return op( $op =>   @_);       }  # n-ary form
  }

sub sum
  { my( $glyph, $format, $content, $from, $to)= @_;
    my $int;
    if( defined( $from) && defined( $to))
      { if( $format->{i} == 1) # todo : use attributes to position better
          { $int= msubsup( mo( $glyph), mrow( $from), mrow( $to)); } 
        elsif( $format->{i} == 2) 
          { $int= msubsup( mo( $glyph), mrow( $from), mrow( $to)); } 
        else
          { $int= munderover( mrow( mo( $glyph)), mrow( $from), mrow( $to)); } 
      }
    elsif( defined( $from))
      { if( $format->{i} == 1) # todo : use attributes to position better
          { $int= munder( mo( $glyph), mrow( $from)); } 
        elsif( $format->{i} ==  2) 
          { $int= munder( { accent => 'true' }, mo( $glyph), mrow( $from)); } 
        else
          { $int= munder( mrow( mo( $glyph)), mrow( $from)); } 
      }
    else
      { $int= mo( $glyph); }
    return mrow( $int, $content);
  }

sub indexes
  { my( $nb_sup, $nb_sub)= (shift(), shift());
    my $base= shift();
    my @sub= splice( @_, 0, $nb_sub);  
    my @sup= @_;
    if( @sub && @sup)
      { return msubsup( $base, mrow( @sub), mrow( @sup)); }
    elsif( @sub)
      { return msub( $base, mrow( @sub)); }
    elsif( @sup)
      { return msup( $base, mrow( @sup)); }
  }

sub chem
  { my( $pre_sub, $post_sub, $pre_sup, $post_sup)= (shift(), shift(), shift(), shift());

    my $exp= shift();

    # order of the indexes: pre_sup, post_sup, pre_sub, post_sub
    my @pre_sup = $pre_sup  ? splice( @_, 0, $pre_sup  ) : ();
    my @post_sup= $post_sup ? splice( @_, 0, $post_sup ) : ();
    my @pre_sub = $pre_sub  ? splice( @_, 0, $pre_sub  ) : ();
    my @post_sub= $post_sub ? splice( @_, 0, $post_sub ) : ();

    if( @_) { die "wrong content for chem element\n", Dump( \@_), "\n"; }

    # math ml wants first pairs of post sub/sup (with none as filler)
    #               then a mprescripts separator
    #               then pairs of pre sub/sup (with none as filler)

    my @indexes;
    while( @post_sub || @post_sup)
      { push @indexes, shift( @post_sub) || none();
        push @indexes, shift( @post_sup) || none();
      }
    if( @pre_sub || @pre_sup)
      { push @indexes, mprescripts(); 
        while( @pre_sub || @pre_sup)
          { push @indexes, shift( @pre_sub) || none();
            push @indexes, shift( @pre_sup) || none();
          }
      }
    return mmultiscripts( $exp, @indexes);
  }

sub tensor
  { my( $positions, $exp)= (shift(), shift());
    my @indexes;
    foreach my $index (@_)
      { my $sup= $positions % 2;
        $positions= int( $positions / 2);
        if( $sup)
          { push @indexes, none(), $index; }
        else 
          { push @indexes, $index, none(); }
      }
    return mmultiscripts( $exp, @indexes);
  }

sub matrix
  { my $format= shift;
    my( $rows, $columns)= (shift, shift);
    #warn "in matrix ($rows, $columns)\n";
    my @rows;
    foreach (1..$rows) 
      { push @rows, mtr( map { mtd( $_) } splice( @_, 0, $columns)); }
    my $matrix= mtable( @rows);
    if( $format->{i} != 1) { $matrix= mfenced( { sep => [ '[',']' ] }, $matrix); }
    return $matrix;
  }


      
sub single_char
  { my ($item)= @_;

    my( $char, $decoration)= $item=~ m{^([^,]*)((?:,[0-4])*)$};
    #warn "in tchar: item = [$item] (decoration is [$decoration]\n" if $decoration;
    
    my $ent; # true if the character is an entity
    if( length( $char) > 1 && $ent{$char})
      { $ent= 1;
        $char= $ent{$char};
      }

    my $mi= tag( mi => $char);

    if( $decoration) 
      { $decoration=~ s{^,}{};
        my @decoration= split /,/, $decoration;
        return decoration( @decoration, $mi); 
      }
    else            
      { return $mi; }
  }

sub decoration
  { my( $vector, $prime, $dot, $bar, $underscore, $exp)= @_;
    # for now several decorations on the same expression are not treated specialcased (no munderover for example)
    if( $vector==1)     { $exp= mover( { accent => 'true' }, $exp, moa('â‡€'));  }
    if( $vector==2)     { $exp= mover( { accent => 'true' }, $exp, moa( '^')); }
    if( $vector==3)     { $exp= mover( { accent => 'true' }, $exp, moa( '~')); }
    if( $vector==4)     { $exp= mover( { accent => 'true' }, $exp, moa( 'â†’')); }
    if( $vector==5)     { $exp= mover( { accent => 'true' }, $exp, moa( 'â€')); }
    if( $prime==1)      { $exp= mrow(  $exp, moa( $ent{prime}));    }
    if( $prime==2)      { $exp= mrow(  $exp, moa( $ent{pprime}));   }
    if( $prime==3)      { $exp= mrow(  $exp, moa( $ent{tprime}));   }
    if( $dot==1)        { $exp= mover( $exp, moa( $ent{dot}));      } 
    if( $dot==2)        { $exp= mover( { accent => 'true' }, $exp, mo( $ent{twodots}));  } 
    if( $dot==3)        { $exp= mover( { accent => 'true' }, $exp, mo( $ent{ellip}));    } 
    if( $bar==1)        { $exp= mover( { accent => 'true' }, $exp, mo( $ent{overline})); }
    if( $underscore==1) { $exp= munder( { accentunder => 'true' }, $exp, mo('~'));            }
    if( $underscore==2) { $exp= munder( { accentunder => 'true' }, $exp, mo('_'));            }
    return $exp; 
  }

sub offset_tweak
  { my( $m, $offset)= @_;
    #warn "processing offset '$offset' for '$m'\n";
    my $points= $offset/65536;
    if( $points >0)      # boundaries are guessed
      { return mrow( msub( mi(''), $m)); }
    elsif( $points >= -6 && $points <= -2)
      { return mrow( msup( mi(''), $m)); }
    else
      { warn "cannot process y offset $offset ($points pt)\n"; }
  }

sub parse_format
  { my( $format_token)= @_;

    return if ! $format_token || ! $format_token->[0];

    my $format={};

    my $format_string= $format_token->[0]; # that's where Parse::RecDescent puts the format string

    # metrics would need to be processed differently I think
    while( $format_string=~ s{^([Mmnuv]|([AcCDijNoORSU])\d+\2|([BfqTVW])"[^"]*"\3|([s])[\d.]*\4|([blrtxyZ])-?[\d.]*\5)}{})
      { my $format_part= $1; 
        if( length( $format_part) == 1)
          { $format->{$format_part}= 1; } # single letter format
        else
          { my $type= substr( $format_part, 0, 1); 
            # remove the format code (first and last char) and surrounding quotes if present
            my $val= $format_part;
            $val=~ s{^(.)(.*?)\1$}{$2};
            $val=~ s{"(.*)"}{$1};
            # from the previous version of the code it looks like some metrics values can be repeated
            # need to investigate
            if( $type && $format->{type} && $val =~ m{^-?[\d.]+$})
              { $format->{$type} += $val; }
            else
              { $format->{$type} = $val; }
          }
      }
    #warn "format: [$format_token->[0]] parsed as ", join( ', ', map { "$_ => $format->{$_}" } sort keys %$format), "\n";
    return $format;
  }


sub apply_format
  { my $format= shift;
    my @e= @_;

    my $m_to_pt= 65536;

    # formats that apply to the single element that's being passed 
    if( my $yoffset = $format->{y})  { $e[0]= apply_yoffset( int($yoffset/$m_to_pt), $e[0]);    }
    if( exists $format->{C})         { if( $format->{C}) { uc_content( @e); }  
                                       else              { lc_content( @e); }
                                     } 

    math_variant( $e[0], $format); 

    # formats that add elements, should be after the previous rules
    if( my $xoffset = $format->{x})  { unshift @e, hspace( int( $xoffset/$m_to_pt)); } # x is "kern value" but seems to be used for spacing
    if( my $lspace  = $format->{l})  { unshift @e, hspace( $lspace/$m_to_pt);  }
    if( my $rspace  = $format->{r})  { push @e, hspace( $rspace/$m_to_pt);     }
    if( $format->{v})                { push @e, tag( mspace => { linebreak => "newline" }); }

    $_->set_format( $format) foreach @e; # so it can be accessed later

    return @e > 1 ? [@e] : $e[0];
  }

sub math_variant
  { my( $e, $format)= @_;

    if( ! UNIVERSAL::isa( $e, 'pelt')) 
      { warn "e is not an elt: [$e] [$e->[0]]\n"; }

    my $text           = $e->text_only;
    my $tag            = $e->tag;
    my $special        = $is_ent{$text} ? 1 : 0;
    my $single_char    = $tag eq 'mi' && length $text == 1 && ! $special; # defaults to 'italic'
    my $single_special = $tag eq 'mi' && length $text == 1 && $special;   # should not be italicized

    #warn "tag: [$tag] text: [$text] special: $special single_char: $single_char single_special: $single_special\n";

    my $mathvariant='';

    if( $single_char) # 1 char, defaults to italics
      { if( $format->{W} eq 'Bold' && ! $format->{B})    
          { $mathvariant= 'bold-italic'; }
        elsif( $format->{W} eq 'Bold' && $format->{B} eq 'Regular')
          { $mathvariant= 'bold'; }
        elsif( $format->{W} || $format->{B})
          { warn "unknown format for char '$text': ", dump_format( $format); }
      }
    elsif( $single_special) # special char, needs to be set to normal if not specifically in italics
      { if( ! $format->{W} && ! $format->{B})
          { $mathvariant= 'normal'; }
        elsif( $format->{W} eq 'Bold' && ! $format->{B})    
          { $mathvariant= 'bold'; }
        elsif( ! $format->{W} && $format->{B} eq 'Italic')
          { $mathvariant= ''; }
        elsif( $format->{W} eq 'Bold' && $format->{B} eq 'Italic')
          { $mathvariant= 'bold-italic'; }
        elsif( $format->{W} || $format->{B})
          { warn "unknown format for special char '$text': ", dump_format( $format); }
      }
    else
      { if( $format->{W} eq 'Bold' && ! $format->{B})    
          { $mathvariant= 'bold'; }
        elsif( ! $format->{W} && $format->{B} eq 'Italic')
          { $mathvariant= 'italic'; }
        elsif( $format->{W} eq 'Bold' && $format->{B} eq 'Italic')
          { $mathvariant= 'bold-italic'; }
        elsif( $format->{W} || $format->{B})
          { warn "unknown format for $tag '$text': ", dump_format( $format); }

      }

    $e->set_att( mathvariant => $mathvariant) if $mathvariant;
    return;
  }


sub apply_yoffset
  { my( $yoffset, $e)= @_;
    if( $yoffset > 0)
      { return mrow( mspace( { height => int($yoffset) } ), $e); }
    else
      { return mrow( mspace( { depth => int(-$yoffset) } ), $e); }
  }

sub uc_content
  { foreach my $e ( @_)
      { foreach ($e->descendants( '#TEXT')) { $_->set_text( uc( $_->text)); } }
  }
sub lc_content
  { foreach my $e ( @_)
      { foreach ($e->descendants( '#TEXT')) { $_->set_text( lc( $_->text)); } }
  }

sub replace_frame_escapes
  { my( $s)= @_;
    $s=~ s{\\(x[0-9a-f][0-9a-f] |.)}{ if( $frame_escape{$1}) 
                                        { $1 }
                                      else
                                        { my $code= $1;
                                          if( $code > 0x07) { chr hex $1; }
                                          else             { '';          }
                                        }
                                    }eg;
    $s=~ s{""}{"}g;
    return $s;
  }


sub flatten { map { ref $_ eq 'ARRAY' ? flatten(@$_) : $_ } @_ }

sub dump_format { my $format=shift; return join ', ', map { "$_=[$format->{$_}]" } sort keys %$format; }

sub dump_item { warn "parsed: ", dump_item_array( @{$_[0]}), "\n"
              #     . "        ", dump_item_hash( %{$_[1]}), "\n"
                ; 
              }
sub dump_item_array   { return join( ', ', map { UNIVERSAL::isa( $_, 'pelt') ? "[elt (" . $_->tag . ")]" : "[$_]" } flatten( @_)); }
sub dump_item_hash    { my %i= @_; return join( ', ', map { "$_ => " . dump_item_array( $i{$_}) } sort keys %i); }

}

# the grammar itself 

exp  : ( node | string | num | char | ind |tnum | <error?> <reject>)          { $return= $item[1]; 1; }
node : ident '[' format(?) exp(s /,/) ']'           { my $node_type= $item{ident};

                                                      my $node= $dp->{$node_type};
                                                      if( !$node) { warn "unknown node type: $item{ident}\n"; }
                                                      # warn "node: $item{ident}\n";
                                                      

                                                      my $format= parse_format( $item{'format(?)'});

                                                      # if the node handler needs the format, it's the 1st arg
                                                      my @args=  $need_format{$node_type} ? ( $format) : ();
                                                     
                                                      push @args, @{$item[4]};

                                                      $return= $node->(@args);
                                                      
                                                      foreach my $r (flatten( $return)) { $r->set_from( $node_type); }

                                                      # should be OK, needs testing though
                                                      $return= apply_format( $format, $return); 
                                                     
                                                      1;
                                                    }
string  : 'string' '[' format(?) '"' tstring '"' ']' { my $string= replace_frame_escapes( $item{tstring}); 
                                                       if( $string=~ m{^\s+$})
                                                         { $return= hspace( 8 * length( $string)); }
                                                       else
                                                         { $return= mtext( $string); }
 
                                                       my $format= parse_format( $item{'format(?)'});
                                                       $return= apply_format( $format, $return);  
                                                       1;
                                                      }
num     : 'num' '[' format(?) tnum ',' '"' tstring '"' ']' { $return= mn( $item{tstring});    
                                                             my $format= parse_format( $item{'format(?)'});
                                                             if( $format->{y}) { $return= offset_tweak( $return, $format->{y}); }
                                                             apply_format( $format, $return); 
                                                             #warn "in num rule: num: [$item{tstring}], format: ", dump_format( $format), ", return: ", $return->sprint, "\n";
                                                             1;
                                                         }
char    : /(char|dummy)/ '[' format(?) tchar  ']'     { my $format= parse_format( $item{'format(?)'});
                                                        $return= $item{tchar};

                                                        if( my $font= $format->{f})           
                                                          { # TODO
                                                            if( $font eq 'Symbol') # replace the character
                                                              {  $return->set_text( join '', map { $symbol{$_} || $_ } split //, $return->text); }
                                                            else
                                                              { $return->set_att( fontfamily => $font); }
                                                          }
  
                                                        $return= apply_format( $format, $return);
                                                        # warn "returning '$return' for char";
                                                        1;
                                                      }
ident   : /\w+/             { $return= $item[1]; 1; }
tnum    : /[+-]?\d+\.\d+/   { $return= $item[1]; 1; }
tchar   : /[^\]]*/          { $return= single_char( $item[1]);   1; }
ind     : /\d+/             { $return= $item[1]; 1; } # a simple number, used for indices, matrix dimensions...
format  : '(*' /[^*]*/ '*)' { $return= $item[2]; 1; }
tstring : <skip:"">/[^"]*/<skip:$item[1]>           { $return= $item[2]; 1; } # need to change skip so we don't skip over whitespaces
G

my $parser = Parse::RecDescent->new( $grammar) or die "Bad grammar!\n";

foreach my $file (@ARGV)
  { if( $file !~ m{\.mif$}) { next; }
    if( $opt{c} && -f filename( mml => $file)) { next; }

    if( $opt{v}) { warn "processing $file\n"; }

    if( !$opt{n})
      { my $mif= slurp( $file);
        $mif= clean_up_mif( $mif);
        warn "mif: $mif\n" if $opt{v};
        if( ! $mif) 
          { if( $opt{v}) { warn "$file not an equation, skipping.\n"; }
            next;
          }
        my $mml_content= $parser->exp( $mif);
        if( ! $mml_content)
          { my $warning= "could not parse mif\n";
            if( $opt{s}) { die  $warning; }
            else         { warn $warning; }
            next;
          }
        my $comment = $opt{C} ? "\n<!-- $opt{C} -->" : "";
        my $root= pelt->new( math => { xmlns => "http://www.w3.org/1998/Math/MathML", mathbackground => "transparent",  displaystyle => "true" }, $mml_content);
        my $mml= ptwig->new->set_root( $root);
        $mml= clean_up_mml( $mml);
        spit( filename( mml => $file), $mml);
        if( $opt{v}) { warn "mml in ", filename( mml => $file), "\n"; } 
      }

  }

sub clean_up_mif
  { my( $mif)= @_;
    my $clean_mif= $mif;
    if( $mif=~ m{<MathFullForm `([^']*)'\s*> # end of MathFullForm})
      { $clean_mif= $1; }

    $clean_mif=~ s{[\r\n]}{}g;
    $clean_mif=~ s{prompt\[\s*(\([^)]*\))?\s*\]}{'char[' . ( $1 && $prompt{$1} ? $prompt{$1} : ' ') . ']'}eg; # hack, replace prompt by ' ' or 'â‹®'

    return $clean_mif;
  }

sub slurp
  { my $file= shift;
    open( my $in, '<', $file) or die "cannot open input file '$file': $!\n";
    local undef $/;
    my $content= <$in>;
    return $content;
  }

sub spit
  { my $file= shift;
    open( my $out, '>:utf8', $file) or die "cannot create file '$file': $!\n";
    print {$out} @_;
  }

sub filename
  { my( $ext, $file)= @_;
    $file=~ s{\.[^.]+$}{.$ext};
    return $file;
  }

sub clean_up_mml
  { my( $mml)= @_;
    my $t= XML::Twig->new( twig_handlers => { #mrow    => \&tmrow,
                                              #mfenced => \&tmfenced,
                                              mtext   => \&tmtext,
                                             'mtr[@class="align_on_equal"]' => \&mtr_atop,
                                             'mspace[@class="list"]' => sub { if( $_->in( 'mtd')) { $_->delete; } $_->del_att( 'class'); },
 
                                            },
                           pretty_print => $opt{i} || 'indented',
                           error_context => 1,
                         )
         ->parse( $mml->sprint);
    return $t->sprint;
  }


sub tmtext
  { my( $t, $mtext)= @_; 
    if( $mtext->prev_sibling_is( 'mtext')) { $mtext->prefix( ' '); }
  }

sub mtr_atop
  { my( $t, $mtr)= @_; 
    warn "align_on_equal found\n"; 
    return;
    if( $mtr->contains_a_single( 'mrow'))
      { my $mrow= $mtr->first_child( 'mrow');
        foreach my $child ( $mrow->children)
          { if( $child->text ne '=' && $child->prev_sibling && $child->prev_sibling->text ne '=')
              { $child->move( last_child => $child->prev_sibling); }
            else
              { $child->wrap_in( 'mtd'); }
          }
         $mrow->erase;
      }
    else
      { warn "atop mtr contains more than 1 mrow\n"; }
    #$mtr->del_att( 'class');
  }

package ptwig;
use base 'XML::Twig';

sub new
  { my $t= shift;
    return bless $t->SUPER::new( elt_class => 'pelt', @_);
  }

1;

package pelt;
use base 'XML::Twig::Elt';

sub new
  { my $t= shift;
    return bless $t->SUPER::new( @_);
  }


# return the value of a format (if the code argument is given), or the entire format hash
sub format
  { my( $elt, $code)= @_;
    my $format= $elt->att( '#format') || {};
    return $code ? $format->{$code} : $format;
  }

sub set_format
  { my $elt= shift;
    my $format= shift || {};
    $elt->set_att( 'data-format' => join ', ', map { "$_: [$format->{$_}]" } keys %$format) if $opt{D};
    return $elt->set_att( '#format' => $format);
  }

sub from     
  { return $_[0]->att( '#from'); }
sub from_in
  { my $elt= shift;
    foreach my $from (@_)
      { if( $elt->from && $elt->from eq $from) { return $elt; } }
    return 0;
  }
sub set_from 
  { my( $elt, $from)= @_;
    $elt->set_att( 'data-from', $from) if $::opt{D}; 
    return $elt->set_att( '#from', $from); 
  }

1;

package main;
__END__
=head1 NAME

  mif2mml - converts MIF equations into MathML 

=head1 OPTIONS

  -c  only converts if the MathML file (.mml) does not exist already

  -C  comment, to add to the beginning of the file

  -v verbose

  -D debug adds debugging attributes to the mml elements 
     - data-format for the Frame format and 
     - data-from   for the frame construct an element comes from

  -i <indent_type> changes the result identation, 'none' or 'indented' (default)

=head1 REQUIREMENTS

  - Perl 5.8+, perl modules XML::Twig and Parse::RecDescent

  - expat 

  -  mathmlsvg (from gtkmathview http://helm.cs.unibo.it/mml-widget/
     there are debian packages for libgtkmathview in sid
     
     alternatively you could use math2svg (L<http://www.grigoriev.ru/svgmath/>) for SVG generation

     those 2 packages are hell to install and configure, especially to get
     the fonts right

  - inkscape for PNG generation (from the SVG, so you also need gtkmathview or math2svg)


=head1 SEE ALSO

MIF Reference Online Manual: L<http://www.adobe.com/devnet/framemaker/pdfs/MIF_Reference.pdf>

=head1 AUTHOR

Michel Rodriguez <mirod@cpan.org>
Bug reports and feature requests should be emailed directly to the author.

=head1 LICENSE

 This program is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License verion 2.0,
 as published by the Free Software Foundation.

 This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details at
 L<http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt>

